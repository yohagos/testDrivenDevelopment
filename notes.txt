TDD - Test Driven Development

    Quote from "Book: The Art of Agile Development":

        "TDD helps produce well-designed, well-tested and
        well-factored code in small, verifiable steps"

#####

So TDD is basically unit testing, right?

    + drive the design
    + tiny steps & run tests (very) frequently
    + robust test suite

#####

Why use TDD?

    - Robust test suite
    - Fear to break code is minimized
    - Less debugging -> through frequently running tests
    - Living documentation for others -> expected behavior of code can be extracted from the test suite
    - Faster code reviews -> strong test suite results in fewer communication channels
    - Faster delivery of value -> equals in more efficiency and faster delivering of production code

    (theoretical discussion to TDD)
    - TDD has a learning curve. It slows you down!
        -> True. So does learning Git or IDE. It also brings a lot of tools
    - TDD is time-consuming - you must write much more code
        -> and the time spent debugging and hot-fixing regressions?
           Only the first month and brings a lot more benefits in the long run
    - Tests are a big cost! And they break by each refactoring and behavioral changes
        -> Criticism of tests in general and not TDD
        -> Minimize overhead with best practices
    - False sense of security, difficult to apply in some places
        -> Those are valid concerns (last module / last branch in this project)

    Two core practices:
        1. Production code best practices
        2. Test code best practices

#####

Red-Green-Refactor Method / lifecycle

    Before we start, we have to think it through!!!!

    Red         -> write a failing test (compilation failure counts)
    Green       -> make it pass. Write the simplest possible thing
    Refactor    -> Clean it up!

    => Hereby it is a constant cycle in which for every change,
        if those are new features or whatever, we should
        start with Red then Green and finally Refactor

    ->  There will be the need to run cycles between the steps of Green and Refactor,
        to make sure all Tests will still pass and to use Zombies to improve all tests

######

After the Requirements are implemented, then ZOMBIES will come 'alive' and stop the progress...
ZOMBIES is an anagram for:

    - Zero
    - One
    - Many
        ->  Zero - One - Many: the code should be able to handle each and every possible scenario
    - Boundary behavior
        ->  The term 'Boundaries' can be for Testers relative fluid and abstract.
            Minimal application for boundaries would be to check for primitive data types like
            length of a String or if the int value is between an range like 0...10
    - Interface definition
    - Exceptional behavior
    - Simple scenarios - simple solutions

Template to improve the written tests.

#####

When to Parameterize?

    When we send different inputs into, but the outputs the same, tests can be merged!
    -> Example: testing password with a blank string, empty string or unacceptable string => login failed

#####

Triangulation

    A technic to writing two or more Assertions for a more Generic Code.
    -> combined the length check and extracted to private Method for more readability in StringUtil

#####

Testing the Internals or the Interface?

    Tests should only test the behavior and the interface, and not the implementation.
    If we have to change the implementation, therefor the tests will break.

#####

TDD Process

    Poor domain understanding (background information) == Poor Design
    - One Assertion (assertEquals or ..) per Test
    - No need to test simple getters -> usually do not contain any logic, just simple return ""

######

Automated Test Best Practices

    - One assertion per test
    - No need to test trivial getters
    - BUT!!! There are exception to the rule:
        ->  the getValue() method contains a math operation and needs to be tested
        ->  getters will be returning different Values, therefore will through the Red-Green-Refactor
            Lifecycle, simple tests can be added, to check if those operations, depending on their value
            will return the expecting value. In the Refactor steps (depending on their priority and complexity)
            those methods can be removed.

########

Nuances while using TDD

    Legacy Code
        - If Tests are not implemented, it was not designed for testability
        - Introduce tests means there is a need to change the code
        - Change the code with confidence, we need to introduce tests
        -> Usually the "chicken-and-egg problem" <-> what came first?

        -> No checklist or concrete method how to introduce tests to legacy code

        Book: "Working Effectively with Legacy Code"
        - Principles and guidelines: (chapters in the book)
            - I don't understand the code well enough to change it
            - My Application has no structure
            - I need to change a Monster Method and I can't write Tests for it
            - How do I know that I'm not breaking anything?
            => Answer to the last to point
                => Characterization tests
                => Tests which only test the actual behavior of those methods. Guideline:
                    1) Assume current behavior is correct (unless an error occur or unexpected calculation)
                    2) Write a Test for the current behavior. Let it fail!
                    3) Change the test to make it pass. (Now we have a documentation about their behavior through tests)
                    4) Repeat
                    5) Change code with confidence