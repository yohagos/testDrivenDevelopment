TDD - Test Driven Development

    Quote from "Book: The Art of Agile Development":

        "TDD helps produce well-designed, well-tested and
        well-factored code in small, verifiable steps"

#####

So TDD is basically unit testing, right?

    + drive the design
    + tiny steps & run tests (very) frequently
    + robust test suite

#####

Why use TDD?

    - Robust test suite
    - Fear to break code is minimized
    - Less debugging -> through frequently running tests
    - Living documentation for others -> expected behavior of code can be extracted from the test suite
    - Faster code reviews -> strong test suite results in fewer communication channels
    - Faster delivery of value -> equals in more efficiency and faster delivering of production code

    (theoretical discussion to TDD)
    - TDD has a learning curve. It slows you down!
        -> True. So does learning Git or IDE. It also brings a lot of tools
    - TDD is time-consuming - you must write much more code
        -> and the time spent debugging and hot-fixing regressions?
           Only the first month and brings a lot more benefits in the long run
    - Tests are a big cost! And they break by each refactoring and behavioral changes
        -> Criticism of tests in general and not TDD
        -> Minimize overhead with best practices
    - False sense of security, difficult to apply in some places
        -> Those are valid concerns (last module / last branch in this project)

    Two core practices:
        1. Production code best practices
        2. Test code best practices

#####

Red-Green-Refactor Method / lifecycle

    Before we start, we have to think it through!!!!

    Red         -> write a failing test (compilation failure counts)
    Green       -> make it pass. Write the simplest possible thing
    Refactor    -> Clean it up!

    => Hereby it is a constant cycle in which for every change,
        if those are new features or whatever, we should
        start with Red then Green and finally Refactor

    ->  There will be the need to run cycles between the steps of Green and Refactor,
        to make sure all Tests will still pass and to use Zombies to improve all tests

######

After the Requirements are implemented, then ZOMBIES will come 'alive' and stop the progress...
ZOMBIES is an anagram for:

    - Zero
    - One
    - Many
        ->  Zero - One - Many: the code should be able to handle each and every possible scenario
    - Boundary behavior
        ->  The term 'Boundaries' can be for Testers relative fluid and abstract.
            Minimal application for boundaries would be to check for primitive data types like
            length of a String or if the int value is between an range like 0...10
    - Interface definition
    - Exceptional behavior
    - Simple scenarios - simple solutions

Template to improve the written tests.

#####

When to Parameterize?

    When we send different inputs into, but the outputs the same, tests can be merged!
    -> Example: testing password with a blank string, empty string or unacceptable string => login failed

